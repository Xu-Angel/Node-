# Redis适合哪些业务场景

常规业务系统的数据库访问中，**读写操作的比例一般在7/3到9/1，也就是说读操作远多于写操作**，因此高并发系统设计里，通过NoSQL技术将热点数据（短期内变动概率小的数据）放入内存以达到减轻DB压力，提升数据访问速度的目的，Redis和MongoDB是当下应用最广泛的NoSQL产品，当然如果系统里的写操作居多，也没有必要使用缓存，因此Redis主要用于解决访问性能和并发能力的问题。除了纯数据缓存的作用之外，得益于其超高速的响应能力，Redis也常用于提供分布式锁的解决方案。

# Redis中各种数据类型的使用场景

Redis的数据存储主要通过key/value实现，key都是string类型，value则分不同的应用场景有五种类型定义：

- string类型：可以包含任何数据（jps图片或者经过序列化的对象，单个key最大可以存储512M的数据），具有全局统计功能的数据，如全局ID生成器、集群配置信息等；

- hash类型：用于存储对象结构的数据，多个field绑定到一个key上（对比使用string类型存储对象的优势在于hash类型可以直接update具体field的值而不影响其他field），如实现SSO，cookie为key，用户信息为value，并有指定过期时间；

- list类型：用于存储需要基于队列或者栈操作的系列数据，如消息队列；

- set类型：用于存储需要维护一个全局不重复的集合，如服务注册发现，可以实现全局去重的功能，如访问网页的独立IP，共同好友等；

- zset类型：用于存储需要维护一个全局不重复但有权重排序的列表可以使用SORTED SET，如积分排行榜、带权重的消息队列。

# 解决Redis缓存穿透和缓存雪崩问题

缓存穿透和雪崩可以看做一个问题，只是严重程度不同；当一个请求到达redis之后发现没有对应的缓存数据，然后向DB发送数据请求，如果能获取到数据那问题就停留在了缓存穿透上，DB获取到的数据会缓存到redis上；如果DB中也没有对应的数据，并且当这样的请求达到一定数量级并且耗用完所有的DB资源，最终导致DB连接异常就出现了缓存雪崩问题。

解决缓存穿透问题的思路有下述几种，不管是否从DB中查找到对应的值（没有值就为null），都在redis中记录一条缓存记录；在Dao层维护一张BitMap，用bit记录对应的key是否有对应值，从而避免冗余的DB操作；后台线程专门用于更新即将过期的Redis数据，从而避免缓存穿透。
解决缓存雪崩问题的思路有下述几种，在DB Connection上添加互斥锁，这样当大量缓存请求失效的时候需要排队去DB请求数据；对设置了相同过期时间的数据设置一个随机值，避免数据集体失效；使用双缓存或者多层缓存策略，需要配合缓存预热。